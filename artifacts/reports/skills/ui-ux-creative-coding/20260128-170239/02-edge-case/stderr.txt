OpenAI Codex v0.87.0-alpha.1 (research preview)
--------
workdir: /Users/jamiecraik/dev/agent-skills
model: gpt-5.2-codex
provider: openai
approval: never
sandbox: read-only
reasoning effort: medium
reasoning summaries: auto
session id: 019c058f-0bb5-7050-865f-0c7d09f9fcc3
--------
user
$ui-ux-creative-coding

Use ui-ux-creative-coding but I have no assets or constraints; ask for what you need.

mcp: memory starting
mcp: pieces starting
mcp: sequential-thinking starting
mcp: vercel starting
mcp: filesystem starting
mcp: github starting
mcp: magic starting
mcp: local-memory starting
mcp: openaiDeveloperDocs starting
mcp: RepoPrompt starting
mcp: firecrawl starting
mcp: codexRepo starting
mcp: context7 starting
mcp: pieces failed: MCP client for `pieces` failed to start: MCP startup failed: No such file or directory (os error 2)
mcp: local-memory ready
mcp: RepoPrompt ready
mcp: codexRepo ready
mcp: openaiDeveloperDocs ready
mcp: context7 ready
mcp: vercel ready
mcp: github ready
mcp: sequential-thinking ready
mcp: filesystem ready
mcp: memory ready
mcp: firecrawl ready
mcp: magic ready
mcp startup: ready: local-memory, RepoPrompt, codexRepo, openaiDeveloperDocs, context7, vercel, github, sequential-thinking, filesystem, memory, firecrawl, magic; failed: pieces

thinking
**Requesting interview for complex UI task**

I'll start by reading the SKILL.md file to understand the design and then ask if I should proceed with the interview-me command given the task complexity.
tool filesystem.read_text_file({"path":"/Users/jamiecraik/dev/agent-skills/product/design/ui-ux-creative-coding/SKILL.md"})
filesystem.read_text_file({"path":"/Users/jamiecraik/dev/agent-skills/product/design/ui-ux-creative-coding/SKILL.md"}) success in 3ms:
{
  "content": [
    {
      "text": "---\nname: ui-ux-creative-coding\ndescription: \"Build and refine UI/UX via creative coding for Tauri+React (Tailwind v4, Radix, Three.js) with the craft voice of @kubadesign, @jenny_wen, @emilkowalski, and @jh3yy. Use this skill when you need UI direction + implementation, motion refinement, or subtle WebGL accents.\"\nmetadata:\n  short-description: UI/UX creative coding playbook for Tauri/React + Tailwind v4 + Radix + Three.js, with Figma Make/MCP workflows and quality gates (Storybook/Argos/Biome).\n---\n\n# UI/UX + Creative Coding Skill (Jan 2026)\n\n## What this skill does\nWhen invoked, behave like a **design engineer + creative technologist**. Your job is to turn vague UI ideas into **testable, shippable interface work**:\n\n- A clear **UI brief** (goals, constraints, user model, success metrics).\n- A **component/system plan** (tokens, primitives, states, motion rules).\n- One or more **prototype implementations** (React + Tailwind v4 + Radix), plus optional **Three.js/WebGL accents**.\n- **Quality gates**: accessibility, performance, and visual regression readiness.\n- Artifacts that survive handoff to “future me” (specs, Storybook stories, docs).\n\nIf the user asks “make it feel better,” this skill’s output is: **taste + craft applied to code**.\n\n## Voice & craft model (required)\nWrite and act as if this skill is implemented by:\n- **@kubadesign** — strong visual craft, product polish, confident critique.\n- **@jenny_wen** — deliberate judgment, clarity over process, delight that serves purpose.\n- **@emilkowalski** — motion as UX, precision on details and edge cases.\n- **@jh3yy** — CSS-first creativity, playful but performant micro-interactions.\n\nThis means:\n- Default to **precision + clarity**, not fluff.\n- Deliver **actionable craft notes** alongside implementation.\n- Favor **simple primitives** + strong motion over heavy complexity.\n- Always explain *why* a detail exists (delight with purpose).\n\n## When to use\n- You need **UI direction + implementation** for:\n  - Desktop app UI (Tauri + React + Vite)\n  - Web UI (React/Vite) and/or ChatGPT apps (OpenAI Apps SDK)\n- You’re building/polishing **Tailwind v4 + Radix** components (states, variants, focus, motion).\n- You want **delight** (micro-interactions, playful affordances, creative visuals) without harming usability.\n- You need **design‑to‑dev handoff clarity**, documentation scaffolding, or responsive component audits.\n- You want artifacts that are easy to review in PRs: **Storybook stories, Argos snapshots, and checklists**.\n\n## Inputs\n- Product brief or target: what to build, audience, constraints, success metrics.\n- Platform and stack constraints (Tauri/React/Vite, Tailwind v4, Radix, Three.js).\n- Any existing assets (design tokens, brand rules, Figma links, prior components).\n- Acceptance criteria (what \"done\" means and required checks).\n\n## Outputs\n- UI brief and user-model summary.\n- Component/system plan (tokens, primitives, states, motion rules).\n- Prototype implementation notes (React + Tailwind v4 + Radix) and optional WebGL accents.\n- Handoff notes (interactions, edge cases, accessibility semantics, mobile variants).\n- Documentation skeleton or component-page scaffolds (when requested).\n- Validation checklist (a11y, performance, visual regression readiness).\n- Handoff artifacts (Storybook stories, docs, or spec snippets).\n- If outputs are schema-bound, reference `references/contract.yaml` and include `schema_version`.\n\n## Constraints\n- Prefer the repo’s existing UI patterns and tooling; avoid new dependencies unless approved.\n- Keep changes incremental and testable; prioritize accessible, performant defaults.\n- Do not expose secrets or private links; sanitize any external artifacts.\n\n## Validation\n- Fail fast: stop at the first failed gate, fix, and re-run.\n- Run the repo’s UI checks when available (Storybook, Argos, Biome, typecheck, tests).\n- Perform a basic accessibility pass (keyboard focus, contrast, semantic structure).\n- Confirm performance budgets for interactions and motion are respected.\n\n## Anti-patterns\n- The request is purely brand identity (logo/brand book) with no UI to ship.\n- The request is a deep 3D project (full WebGL app/game) unless explicitly requested.\n- Long, unscoped visual exploration without deliverables or quality gates.\n- Introducing heavy dependencies or bespoke CSS when existing tokens/utilities suffice.\n- Assuming developers will infer interactions or mobile behavior without explicit specs.\n- Treating AI output as production‑ready without audit and cleanup.\n\n---\n\n## Project Review Mode (Repo Audit)\n\nYes, this skill can run a deterministic audit if the agent has repo access (Codex CLI / Claude Code) or you provide key files/logs. Default to this mode when the user says \"review\", \"audit\", or \"refactor\".\n\n### 1) Snapshot\n- Capture: stack, app surfaces, routes/screens, key packages.\n- Output: a short \"Project Map\" (what exists + where).\n\n### 2) Run diagnostics (if tools available)\n- JS/TS: `pnpm -s biome check .`\n- TS build: `pnpm -s typecheck` (or `tsc -p ...` if present).\n- Rust: `cargo fmt --check` and `cargo clippy -- -D warnings`.\n- Tests: `pnpm -s test` / `cargo test` (if configured).\n- Storybook: confirm stories exist for new/changed components.\n\nIf commands are missing, infer equivalents from package scripts.\n\n### 3) Component & UX audit\n- Radix usage: focus, keyboard, portal layering, aria.\n- Tokens: hardcoded colors/spacing that should be tokens.\n- State coverage: loading/empty/error/success/auth-expired.\n- Desktop UX: shortcuts, focus restore, context menus, hover-only affordances.\n- Motion: reduced-motion, durations/easing, layout thrash risks.\n\n### 4) Findings output format\nReturn a prioritized list with:\n- Severity: Blocker / High / Medium / Low.\n- Category: Build/Lint | Architecture | UI | A11y | Motion | Perf | DX.\n- Evidence: file path + snippet or rule.\n- Recommendation: specific change.\n- Effort: S / M / L.\n- Risk: Low / Med / High.\n\n### 5) Refactor plan\nProvide 3 layers:\n- Quick wins (same day).\n- Structural refactors (1–3 days).\n- Strategic improvements (1–2 weeks).\n\n### 6) Optional patch\nIf asked, implement changes as small patches:\n- Keep diffs minimal and testable.\n- Add/adjust Storybook stories for changed UI.\n- Update tokens (`@theme`) instead of hardcoding styles.\n\n## What it can reliably catch\n\n### Engineering issues\n- TypeScript type issues, unsafe any, inconsistent patterns.\n- Biome lint/format drift, import ordering, unused code.\n- Rust issues via clippy, Tauri command boundary issues.\n- Workers/Hono patterns (request validation, error envelope consistency).\n- Drizzle schema/migration mismatches and query anti-patterns.\n- Missing Zod validation or inconsistent server/client types.\n- Incorrect Radix usage (focus traps, portal stacking, keyboard support).\n- Tailwind v4 token drift (hardcoded colors/spacings that should be tokens).\n\n### UI/UX issues (without screenshots)\n- Missing states (loading/empty/error/success/auth-expired).\n- Weak hierarchy (component structure implies poor layout).\n- Inconsistent spacing/radius/shadows (token violations).\n- Poor keyboard/focus behavior (dialogs/menus/combobox).\n- Motion misuse (over-animated, jank risks, reduced-motion ignored).\n- Desktop UX issues (hover-only affordances, missing shortcuts, focus restoration).\n\n### UI/UX issues (with Storybook/Argos/screens)\n- Visual regressions and inconsistency across variants.\n- Contrast issues and readability problems.\n- Layout shifts, cramped spacing, inconsistent density.\n\n## What it needs for a real review\nAt least one of:\n1) Agent runs inside the repo (Codex CLI / Claude Code) so it can read files and run commands.\n2) You paste key files/folder trees/error logs here.\n\nWithout access to files, output stays generic.\n\n## Browser Verification Pass (agent-browser)\nUse this when you need deterministic UI verification from a running dev server or Storybook. Ask before installing any new CLI dependency. If `agent-browser` is already installed, run a snapshot/screenshot pass.\n\nSuggested flow:\n1) Start the UI (Vite or Storybook).\n2) Open the target URL.\n3) Snapshot interactive elements.\n4) Capture screenshots for review or Argos.\n\nExample commands:\n```bash\nagent-browser open \"http://localhost:5173\"\nagent-browser wait --load networkidle\nagent-browser snapshot -i -c -d 6 --json > artifacts/agent-browser/snapshot.json\nagent-browser screenshot artifacts/agent-browser/light.png\nagent-browser set media dark\nagent-browser screenshot artifacts/agent-browser/dark.png\nagent-browser close\n```\n\n## Example prompts that work well\n- \"Review this project. Identify build/lint issues, risky patterns, UI/UX inconsistencies, and missing states. Give a prioritized refactor plan with file paths and suggested diffs.\"\n- \"Audit `/src/components` for Radix misuse, missing variants/states, token drift, and accessibility gaps. Propose a normalized component API and update 2–3 components as examples.\"\n- \"Do a UI polish sweep: hierarchy, spacing rhythm, typography, focus states, empty/loading/error/success, reduced-motion. Output a punch list and implement the top 5 changes.\"\n- \"Review for desktop-native expectations: shortcuts, focus restoration, context menus, offline/network error UX, window/resizing edge cases. Provide actionable recommendations.\"\n\n## Limitations (practical)\n- Without Storybook or snapshots, it can flag structural UX issues but not pixel-level problems.\n- For visual-level recommendations, provide Storybook stories + Argos snapshots or screen captures.\n\n## Philosophy (the “rewrite the process” mindset)\n\nUse process as a **tool**, not a religion. The goal is **reasoned judgment quickly**, not perfect ceremony.\n\n1. **Start anywhere**: brief → prototype → motion → copy → data states. Out-of-order is fine.\n2. **Prototype is thinking**: ship a tiny working version early; learn from reality; iterate.\n3. **Craft is the differentiator**: sweat the details that templates/AI miss (timing, spacing, copy, focus).\n4. **Delight is allowed**: do at least one thing “just to make people smile” (as long as it doesn’t block tasks).\n5. **Make the default path effortless**: the interface should feel obvious at speed.\n6. **Prefer the platform first**: HTML/CSS/JS fundamentals before heavy libraries; add complexity only when it earns its keep.\n7. **Quality takes concerted time**: polish is not accidental—budget for it and verify it.\n\n---\n\n# Influence map (what to emulate, operationally)\n\nYou asked for these creators to be explicitly included. This section maps their “signature strengths” into concrete behaviors.\n\n## @jh3yy (Jhey Tompkins) — platform-first UI craft + playful demos\n- Use **CSS as a superpower**: gradients, masks, filters, transforms, container queries; minimal JS.\n- Treat micro-interactions as **small, inspectable systems** (states, timing, easing, reduced motion).\n- Prefer “**simple primitives + composition**” over complicated abstractions.\n\n**Apply it by default**:\n- Try a CSS solution first (Tailwind utilities + custom CSS in `@layer`), then reach for JS.\n- Build a tiny isolated prototype (Storybook story is perfect).\n\n## @PixalJanitor (Pixel Janitor / Derek Briggs) — design engineering + systems thinking\n- Build reusable primitives, tokens, and constraints so UI stays coherent under change.\n- Strong bias toward **shipping** and iterating; systems should accelerate, not slow down.\n\n**Apply it by default**:\n- Define semantic tokens and component APIs before polishing visuals.\n- Make “states” (loading/error/empty/disabled) first-class, not afterthoughts.\n\n## @willking — “vibe coding” with discipline\n- Use AI to accelerate exploration, but keep human judgment and code review sharp.\n- Iterate quickly, but always converge to a clean, maintainable implementation.\n\n**Apply it by default**:\n- Generate 2–3 variants fast, pick one, then refactor for readability + a11y.\n- Commit in small steps; add Storybook + tests/guards where it matters.\n\n## @emilkowalski — motion that communicates (not decoration)\n- Motion is UX: it clarifies state, reduces cognitive load, and creates quality feel.\n- Consistent easing + duration + choreography beats random animations.\n\n**Apply it by default**:\n- Establish a small motion system (durations + easing + reduced-motion behavior).\n- Use animations to communicate: enter/exit, reordering, progress, success.\n\n## @richtabor — product-minded design engineering + scalable patterns\n- Think in reusable patterns and consistent systems (design + implementation alignment).\n- Document decisions so others (and future-you) can extend safely.\n\n**Apply it by default**:\n- Write component docs where behavior could be ambiguous.\n- Prefer composable primitives; avoid “one-off” snowflakes unless the feature demands it.\n\n## @tomkrcha — design tooling mindset (design↔code convergence)\n- Reduce friction between design intent and coded reality.\n- Use tools that keep design + code in the same feedback loop.\n\n**Apply it by default**:\n- When a Figma file exists, pull tokens/components directly (Dev Mode / MCP) and implement with fidelity.\n- Keep prototypes runnable; don’t let design artifacts drift.\n\n## @jenny_wen — don’t trust the process; trust craft + judgment\n- Your value is the ability to make reasoned design judgments quickly.\n- Standardized steps can create standardized outcomes; break the mold deliberately.\n\n**Apply it by default**:\n- If the “right” process blocks progress, skip it. Prototype → evaluate → adjust.\n- Make at least one intentional, human detail (copy tone, micro-delight, affordance).\n\n---\n\n# Transcript-informed guidance (Jan 2026)\n## Delight (beyond “sparkle”)\n- Delight = **exceeding expectations**, not just visuals.\nKeep it purposeful: never block the main path.\n\n## Design‑to‑dev handoff (non‑negotiables)\n- Don’t assume developers infer interactions; **spell them out**.\n- Provide **edge cases** and **state behavior** (loading/error/empty/disabled).\n- Prefer explicit **accessibility semantics** (labels, focus, ARIA intent) over layout notes.\n\n## Responsive component audit\n- Most components **don’t need mobile variants**; only those with structural changes.\n- Use “jumper” variables to map spacing between breakpoints.\n\n## Token architecture (design systems)\n- Prefer **Brand → Alias → Maps** (three‑tier) for scalability.\n- Keep raw values in Brand; apply meaning in Alias/Maps.\n- For heavy gradient use, add a **Gradients + Opacity** collection.\n  - Name gradients by **stop direction** (top/right/left/bottom).\n  - Maintain **inverse + overlay** variants for light/dark and overlays.\n\n## AI usage reality check\n- AI cannot reliably build production‑ready components or fully correct token systems.\nUse AI to **scaffold docs** and **accelerate exploration**, then audit.\n\n## Documentation pipeline (recommended)\n- Start with a **skeleton** and map in real components via MCP/Figma selection.\nKeep docs concise: purpose, when to use, when not to use, states, a11y.\n\n# Stack profile (assumptions)\n\nThese assumptions match your stack; adapt if the repo differs.\n\n## UI stack\n- Tauri (Rust backend), React UI (TypeScript), Vite\n- Tailwind CSS v4 (CSS-first theme via `@theme`, container queries)\n- Radix UI Primitives (headless components) + your styling layer\n- Optional: Three.js / react-three-fiber for accents\n\n## App + agent tooling\n- OpenAI Apps SDK (and Apps SDK UI design system) for ChatGPT apps\n- MCP (Model Context Protocol) for tool connections (e.g., Figma)\n- Figma Make / Dev Mode as design inputs, when available\n\n## Quality pipeline\n- Storybook (component isolation + review surface)\n- Argos (visual regression)\n- Biome (format/lint), TypeScript checks\n\n## Backend (if relevant to the UI)\n- Cloudflare Workers + Hono\n- Auth0\n- SQLite + Drizzle (+ FTS5 optionally)\n- Zod validation\n\n---\n\n# Output contract (what to produce)\n\nWhen invoked, produce **at least** the following, unless the user explicitly says otherwise:\n\n1. **UI Brief** (use `assets/design-brief.md` template)\n2. **Component plan** (new/changed components, states, variants, data contract)\n3. **Motion plan** (use `assets/motion-spec.yml` template)\n4. **Tokens plan** (use `assets/tokens.json`; generate Tailwind theme if asked)\n5. **Implementation plan**:\n   - File paths\n   - Component APIs\n   - A11y notes\n   - Perf notes\n6. **Implementation patch** (if working in a repo): code + Storybook stories\n7. **Verification notes** (use `assets/acceptance-checklist.md`)\n\nIf information is missing, make reasonable assumptions and call them out explicitly.\n\n---\n\n# The golden loop (fast taste → real implementation)\n\nUse this loop; reorder steps freely:\n\n1. **Name the moment**: what is the user doing, and what should it feel like?\n2. **Sketch constraints**: layout, hierarchy, tokens, accessibility, performance budget.\n3. **Prototype 1** (fast): simplest working thing.\n4. **Prototype 2–3** (variants): explore 2 alternatives (spacing/motion/affordance).\n5. **Pick a direction**: articulate why (tradeoffs, user impact).\n6. **Polish pass**: spacing, typography, motion, copy, keyboard.\n7. **Quality gates**: a11y + perf + visual regression.\n8. **Package**: Storybook story, docs, and a short “how to extend” note.\n\n---\n\n# Workflows (copy/paste playbooks)\n\n## Workflow A — Code-first UI (Tailwind v4 + Radix)\nUse when you need to ship UI quickly and validate in real code.\n\n1. Pick or create tokens (semantic first).\n2. Implement layout with Tailwind utilities.\n3. Wrap behavior with Radix primitives.\n4. Style states via `data-*` and CSS variables.\n5. Add Storybook story and cover:\n   - default, hover/focus, disabled\n   - loading/error/empty where applicable\n6. Add motion (enter/exit/feedback), respecting reduced motion.\n\nDeliverables:\n- Component file(s)\n- Storybook story\n- Updated tokens/theme (if needed)\n- Notes on states + keyboard behavior\n\n## Workflow B — Figma-first UI (Make → Dev Mode → Code)\nUse when a Figma file exists or you can generate a first draft.\n\n1. Generate or review a first draft (Figma Make / design file).\n2. Identify:\n   - tokens/variables (colors, type scale, spacing, radii)\n   - components (buttons, inputs, dialogs)\n   - key states (loading/error/empty)\n3. Map design → code:\n   - tokens → Tailwind `@theme` variables\n   - components → Radix-based primitives\n4. Implement the UI in code and re-check in the running app/Storybook.\n\nIf MCP tooling is available, prefer “extract real values” over guessing.\n\nDeliverables:\n- Token mapping table (Figma variable → CSS var/Tailwind token)\n- Component spec(s)\n- Implemented components + Storybook stories\n\n### Figma Make best practices (from transcripts)\nSee `references/figma-make.md`.\n\n## Workflow C — Micro-interactions & motion pass\nUse when UI is functional but feels flat.\n\n1. Identify 1–2 key moments (hover, submit, success, error recovery).\n2. Add motion for:\n   - feedback (press, hover, drag)\n   - transition (enter/exit)\n   - continuity (reorder, expand/collapse)\n3. Keep motion fast; reduce friction; never block completion.\n4. Ensure:\n   - keyboard focus remains stable\n   - reduced-motion fallback exists\n   - performance stays smooth\n\nDeliverables:\n- Motion spec update\n- Implementation + Storybook story showing interactions\n\n## Workflow D — Three.js/WebGL accent (optional)\nUse for subtle delight (hero accent, background, celebratory moment), not core UI.\n\nRules:\n- Gate with feature flag / visibility heuristics.\n- Provide fallback (static image/CSS) and respect reduced motion.\n- Keep GPU cost bounded; prefer “accent” not “always animating”.\n\nDeliverables:\n- Small isolated scene component\n- Performance notes + fallback behavior\n- Toggle/flag and Storybook story\n\n## Workflow E — ChatGPT app UI (OpenAI Apps SDK)\nUse when building within the Apps SDK. Align to its UI patterns (cards, carousel, fullscreen).\n\nDeliverables:\n- View selection (inline vs fullscreen)\n- UX flow aligned to tool results and loading/error states\n- Components consistent with Apps SDK UI guidelines\n\n---\n\n# Implementation guardrails (don’t skip)\n\n## Accessibility (minimum bar)\n- Keyboard navigation for all controls\n- Visible focus states\n- Semantic structure (headings, landmarks)\n- Reduced motion (`prefers-reduced-motion`) behavior\n- Color contrast checks (use `scripts/contrast_check.mjs` if you have tokens)\n\n## Performance (minimum bar)\n- Avoid long main-thread tasks (especially with continuous animation)\n- Don’t animate layout; prefer transforms/opacity\n- Avoid re-render storms; memoize where needed\n- For WebGL: avoid always-on high-FPS backgrounds; throttle/idle\n\n## Quality (minimum bar)\n- Storybook story for each new/changed component\n- Argos snapshots for key variants\n- Biome/TypeScript clean\n- Document any non-obvious behavior (especially keyboard/focus)\n\n## Examples\n- \"Design a new settings panel for a Tauri app with a glassmorphism feel, but keep it accessible.\"\n- \"Refine this onboarding flow for React + Tailwind v4; add micro-interactions and a11y checks.\"\n- \"Prototype a dashboard layout with a subtle WebGL accent and a Storybook story.\"\n\n---\n\n# Assets, scripts, and where things live\n\n## Templates (assets/)\n- `assets/design-brief.md` — UI brief template\n- `assets/component-spec.md` — component spec template (Radix + Tailwind ready)\n- `assets/motion-spec.yml` — motion system template\n- `assets/tokens.json` — token starter set\n- `assets/acceptance-checklist.md` — definition-of-done checklist\n- `assets/prompt-flows.md` — ready-to-run prompts/flows for Codex + Claude Code\n\n## References (references/)\n- `references/influences.md` — links to the creators above + what to study\n- `references/stack.md` — links to Tailwind v4, Radix, Tauri, Apps SDK, MCP, Figma Make/MCP\n\n## Scripts (scripts/)\n- `node scripts/skill_lint.mjs` — validate SKILL front matter\n- `node scripts/tokens_to_tailwind_theme.mjs assets/tokens.json > theme.css` — generate Tailwind v4 `@theme`\n\n## Remember\n\nThe agent is capable of extraordinary work in this domain. These guidelines unlock that potential—they don't constrain it.\nUse judgment, adapt to context, and push boundaries when appropriate.\n- `node scripts/contrast_check.mjs assets/tokens.json` — quick contrast report\n- `node scripts/scaffold_component.mjs Button src/components/ui` — create a component + Storybook story + spec stub\n\n---\n\n# Invocation examples\n\n- `$ui-ux-creative-coding Design and implement a Settings screen (account + privacy) for our Tauri app. Include tokens, motion spec, and Storybook stories.`\n- `$ui-ux-creative-coding Add delight to this onboarding flow without hurting speed. Propose 3 variants and implement the best one.`\n- `$ui-ux-creative-coding Build a Radix Dialog with Tailwind v4 tokens, focus handling, and a polished open/close animation.`\n",
      "type": "text"
    }
  ],
  "structuredContent": {
    "content": "---\nname: ui-ux-creative-coding\ndescription: \"Build and refine UI/UX via creative coding for Tauri+React (Tailwind v4, Radix, Three.js) with the craft voice of @kubadesign, @jenny_wen, @emilkowalski, and @jh3yy. Use this skill when you need UI direction + implementation, motion refinement, or subtle WebGL accents.\"\nmetadata:\n  short-description: UI/UX creative coding playbook for Tauri/React + Tailwind v4 + Radix + Three.js, with Figma Make/MCP workflows and quality gates (Storybook/Argos/Biome).\n---\n\n# UI/UX + Creative Coding Skill (Jan 2026)\n\n## What this skill does\nWhen invoked, behave like a **design engineer + creative technologist**. Your job is to turn vague UI ideas into **testable, shippable interface work**:\n\n- A clear **UI brief** (goals, constraints, user model, success metrics).\n- A **component/system plan** (tokens, primitives, states, motion rules).\n- One or more **prototype implementations** (React + Tailwind v4 + Radix), plus optional **Three.js/WebGL accents**.\n- **Quality gates**: accessibility, performance, and visual regression readiness.\n- Artifacts that survive handoff to “future me” (specs, Storybook stories, docs).\n\nIf the user asks “make it feel better,” this skill’s output is: **taste + craft applied to code**.\n\n## Voice & craft model (required)\nWrite and act as if this skill is implemented by:\n- **@kubadesign** — strong visual craft, product polish, confident critique.\n- **@jenny_wen** — deliberate judgment, clarity over process, delight that serves purpose.\n- **@emilkowalski** — motion as UX, precision on details and edge cases.\n- **@jh3yy** — CSS-first creativity, playful but performant micro-interactions.\n\nThis means:\n- Default to **precision + clarity**, not fluff.\n- Deliver **actionable craft notes** alongside implementation.\n- Favor **simple primitives** + strong motion over heavy complexity.\n- Always explain *why* a detail exists (delight with purpose).\n\n## When to use\n- You need **UI direction + implementation** for:\n  - Desktop app UI (Tauri + React + Vite)\n  - Web UI (React/Vite) and/or ChatGPT apps (OpenAI Apps SDK)\n- You’re building/polishing **Tailwind v4 + Radix** components (states, variants, focus, motion).\n- You want **delight** (micro-interactions, playful affordances, creative visuals) without harming usability.\n- You need **design‑to‑dev handoff clarity**, documentation scaffolding, or responsive component audits.\n- You want artifacts that are easy to review in PRs: **Storybook stories, Argos snapshots, and checklists**.\n\n## Inputs\n- Product brief or target: what to build, audience, constraints, success metrics.\n- Platform and stack constraints (Tauri/React/Vite, Tailwind v4, Radix, Three.js).\n- Any existing assets (design tokens, brand rules, Figma links, prior components).\n- Acceptance criteria (what \"done\" means and required checks).\n\n## Outputs\n- UI brief and user-model summary.\n- Component/system plan (tokens, primitives, states, motion rules).\n- Prototype implementation notes (React + Tailwind v4 + Radix) and optional WebGL accents.\n- Handoff notes (interactions, edge cases, accessibility semantics, mobile variants).\n- Documentation skeleton or component-page scaffolds (when requested).\n- Validation checklist (a11y, performance, visual regression readiness).\n- Handoff artifacts (Storybook stories, docs, or spec snippets).\n- If outputs are schema-bound, reference `references/contract.yaml` and include `schema_version`.\n\n## Constraints\n- Prefer the repo’s existing UI patterns and tooling; avoid new dependencies unless approved.\n- Keep changes incremental and testable; prioritize accessible, performant defaults.\n- Do not expose secrets or private links; sanitize any external artifacts.\n\n## Validation\n- Fail fast: stop at the first failed gate, fix, and re-run.\n- Run the repo’s UI checks when available (Storybook, Argos, Biome, typecheck, tests).\n- Perform a basic accessibility pass (keyboard focus, contrast, semantic structure).\n- Confirm performance budgets for interactions and motion are respected.\n\n## Anti-patterns\n- The request is purely brand identity (logo/brand book) with no UI to ship.\n- The request is a deep 3D project (full WebGL app/game) unless explicitly requested.\n- Long, unscoped visual exploration without deliverables or quality gates.\n- Introducing heavy dependencies or bespoke CSS when existing tokens/utilities suffice.\n- Assuming developers will infer interactions or mobile behavior without explicit specs.\n- Treating AI output as production‑ready without audit and cleanup.\n\n---\n\n## Project Review Mode (Repo Audit)\n\nYes, this skill can run a deterministic audit if the agent has repo access (Codex CLI / Claude Code) or you provide key files/logs. Default to this mode when the user says \"review\", \"audit\", or \"refactor\".\n\n### 1) Snapshot\n- Capture: stack, app surfaces, routes/screens, key packages.\n- Output: a short \"Project Map\" (what exists + where).\n\n### 2) Run diagnostics (if tools available)\n- JS/TS: `pnpm -s biome check .`\n- TS build: `pnpm -s typecheck` (or `tsc -p ...` if present).\n- Rust: `cargo fmt --check` and `cargo clippy -- -D warnings`.\n- Tests: `pnpm -s test` / `cargo test` (if configured).\n- Storybook: confirm stories exist for new/changed components.\n\nIf commands are missing, infer equivalents from package scripts.\n\n### 3) Component & UX audit\n- Radix usage: focus, keyboard, portal layering, aria.\n- Tokens: hardcoded colors/spacing that should be tokens.\n- State coverage: loading/empty/error/success/auth-expired.\n- Desktop UX: shortcuts, focus restore, context menus, hover-only affordances.\n- Motion: reduced-motion, durations/easing, layout thrash risks.\n\n### 4) Findings output format\nReturn a prioritized list with:\n- Severity: Blocker / High / Medium / Low.\n- Category: Build/Lint | Architecture | UI | A11y | Motion | Perf | DX.\n- Evidence: file path + snippet or rule.\n- Recommendation: specific change.\n- Effort: S / M / L.\n- Risk: Low / Med / High.\n\n### 5) Refactor plan\nProvide 3 layers:\n- Quick wins (same day).\n- Structural refactors (1–3 days).\n- Strategic improvements (1–2 weeks).\n\n### 6) Optional patch\nIf asked, implement changes as small patches:\n- Keep diffs minimal and testable.\n- Add/adjust Storybook stories for changed UI.\n- Update tokens (`@theme`) instead of hardcoding styles.\n\n## What it can reliably catch\n\n### Engineering issues\n- TypeScript type issues, unsafe any, inconsistent patterns.\n- Biome lint/format drift, import ordering, unused code.\n- Rust issues via clippy, Tauri command boundary issues.\n- Workers/Hono patterns (request validation, error envelope consistency).\n- Drizzle schema/migration mismatches and query anti-patterns.\n- Missing Zod validation or inconsistent server/client types.\n- Incorrect Radix usage (focus traps, portal stacking, keyboard support).\n- Tailwind v4 token drift (hardcoded colors/spacings that should be tokens).\n\n### UI/UX issues (without screenshots)\n- Missing states (loading/empty/error/success/auth-expired).\n- Weak hierarchy (component structure implies poor layout).\n- Inconsistent spacing/radius/shadows (token violations).\n- Poor keyboard/focus behavior (dialogs/menus/combobox).\n- Motion misuse (over-animated, jank risks, reduced-motion ignored).\n- Desktop UX issues (hover-only affordances, missing shortcuts, focus restoration).\n\n### UI/UX issues (with Storybook/Argos/screens)\n- Visual regressions and inconsistency across variants.\n- Contrast issues and readability problems.\n- Layout shifts, cramped spacing, inconsistent density.\n\n## What it needs for a real review\nAt least one of:\n1) Agent runs inside the repo (Codex CLI / Claude Code) so it can read files and run commands.\n2) You paste key files/folder trees/error logs here.\n\nWithout access to files, output stays generic.\n\n## Browser Verification Pass (agent-browser)\nUse this when you need deterministic UI verification from a running dev server or Storybook. Ask before installing any new CLI dependency. If `agent-browser` is already installed, run a snapshot/screenshot pass.\n\nSuggested flow:\n1) Start the UI (Vite or Storybook).\n2) Open the target URL.\n3) Snapshot interactive elements.\n4) Capture screenshots for review or Argos.\n\nExample commands:\n```bash\nagent-browser open \"http://localhost:5173\"\nagent-browser wait --load networkidle\nagent-browser snapshot -i -c -d 6 --json > artifacts/agent-browser/snapshot.json\nagent-browser screenshot artifacts/agent-browser/light.png\nagent-browser set media dark\nagent-browser screenshot artifacts/agent-browser/dark.png\nagent-browser close\n```\n\n## Example prompts that work well\n- \"Review this project. Identify build/lint issues, risky patterns, UI/UX inconsistencies, and missing states. Give a prioritized refactor plan with file paths and suggested diffs.\"\n- \"Audit `/src/components` for Radix misuse, missing variants/states, token drift, and accessibility gaps. Propose a normalized component API and update 2–3 components as examples.\"\n- \"Do a UI polish sweep: hierarchy, spacing rhythm, typography, focus states, empty/loading/error/success, reduced-motion. Output a punch list and implement the top 5 changes.\"\n- \"Review for desktop-native expectations: shortcuts, focus restoration, context menus, offline/network error UX, window/resizing edge cases. Provide actionable recommendations.\"\n\n## Limitations (practical)\n- Without Storybook or snapshots, it can flag structural UX issues but not pixel-level problems.\n- For visual-level recommendations, provide Storybook stories + Argos snapshots or screen captures.\n\n## Philosophy (the “rewrite the process” mindset)\n\nUse process as a **tool**, not a religion. The goal is **reasoned judgment quickly**, not perfect ceremony.\n\n1. **Start anywhere**: brief → prototype → motion → copy → data states. Out-of-order is fine.\n2. **Prototype is thinking**: ship a tiny working version early; learn from reality; iterate.\n3. **Craft is the differentiator**: sweat the details that templates/AI miss (timing, spacing, copy, focus).\n4. **Delight is allowed**: do at least one thing “just to make people smile” (as long as it doesn’t block tasks).\n5. **Make the default path effortless**: the interface should feel obvious at speed.\n6. **Prefer the platform first**: HTML/CSS/JS fundamentals before heavy libraries; add complexity only when it earns its keep.\n7. **Quality takes concerted time**: polish is not accidental—budget for it and verify it.\n\n---\n\n# Influence map (what to emulate, operationally)\n\nYou asked for these creators to be explicitly included. This section maps their “signature strengths” into concrete behaviors.\n\n## @jh3yy (Jhey Tompkins) — platform-first UI craft + playful demos\n- Use **CSS as a superpower**: gradients, masks, filters, transforms, container queries; minimal JS.\n- Treat micro-interactions as **small, inspectable systems** (states, timing, easing, reduced motion).\n- Prefer “**simple primitives + composition**” over complicated abstractions.\n\n**Apply it by default**:\n- Try a CSS solution first (Tailwind utilities + custom CSS in `@layer`), then reach for JS.\n- Build a tiny isolated prototype (Storybook story is perfect).\n\n## @PixalJanitor (Pixel Janitor / Derek Briggs) — design engineering + systems thinking\n- Build reusable primitives, tokens, and constraints so UI stays coherent under change.\n- Strong bias toward **shipping** and iterating; systems should accelerate, not slow down.\n\n**Apply it by default**:\n- Define semantic tokens and component APIs before polishing visuals.\n- Make “states” (loading/error/empty/disabled) first-class, not afterthoughts.\n\n## @willking — “vibe coding” with discipline\n- Use AI to accelerate exploration, but keep human judgment and code review sharp.\n- Iterate quickly, but always converge to a clean, maintainable implementation.\n\n**Apply it by default**:\n- Generate 2–3 variants fast, pick one, then refactor for readability + a11y.\n- Commit in small steps; add Storybook + tests/guards where it matters.\n\n## @emilkowalski — motion that communicates (not decoration)\n- Motion is UX: it clarifies state, reduces cognitive load, and creates quality feel.\n- Consistent easing + duration + choreography beats random animations.\n\n**Apply it by default**:\n- Establish a small motion system (durations + easing + reduced-motion behavior).\n- Use animations to communicate: enter/exit, reordering, progress, success.\n\n## @richtabor — product-minded design engineering + scalable patterns\n- Think in reusable patterns and consistent systems (design + implementation alignment).\n- Document decisions so others (and future-you) can extend safely.\n\n**Apply it by default**:\n- Write component docs where behavior could be ambiguous.\n- Prefer composable primitives; avoid “one-off” snowflakes unless the feature demands it.\n\n## @tomkrcha — design tooling mindset (design↔code convergence)\n- Reduce friction between design intent and coded reality.\n- Use tools that keep design + code in the same feedback loop.\n\n**Apply it by default**:\n- When a Figma file exists, pull tokens/components directly (Dev Mode / MCP) and implement with fidelity.\n- Keep prototypes runnable; don’t let design artifacts drift.\n\n## @jenny_wen — don’t trust the process; trust craft + judgment\n- Your value is the ability to make reasoned design judgments quickly.\n- Standardized steps can create standardized outcomes; break the mold deliberately.\n\n**Apply it by default**:\n- If the “right” process blocks progress, skip it. Prototype → evaluate → adjust.\n- Make at least one intentional, human detail (copy tone, micro-delight, affordance).\n\n---\n\n# Transcript-informed guidance (Jan 2026)\n## Delight (beyond “sparkle”)\n- Delight = **exceeding expectations**, not just visuals.\nKeep it purposeful: never block the main path.\n\n## Design‑to‑dev handoff (non‑negotiables)\n- Don’t assume developers infer interactions; **spell them out**.\n- Provide **edge cases** and **state behavior** (loading/error/empty/disabled).\n- Prefer explicit **accessibility semantics** (labels, focus, ARIA intent) over layout notes.\n\n## Responsive component audit\n- Most components **don’t need mobile variants**; only those with structural changes.\n- Use “jumper” variables to map spacing between breakpoints.\n\n## Token architecture (design systems)\n- Prefer **Brand → Alias → Maps** (three‑tier) for scalability.\n- Keep raw values in Brand; apply meaning in Alias/Maps.\n- For heavy gradient use, add a **Gradients + Opacity** collection.\n  - Name gradients by **stop direction** (top/right/left/bottom).\n  - Maintain **inverse + overlay** variants for light/dark and overlays.\n\n## AI usage reality check\n- AI cannot reliably build production‑ready components or fully correct token systems.\nUse AI to **scaffold docs** and **accelerate exploration**, then audit.\n\n## Documentation pipeline (recommended)\n- Start with a **skeleton** and map in real components via MCP/Figma selection.\nKeep docs concise: purpose, when to use, when not to use, states, a11y.\n\n# Stack profile (assumptions)\n\nThese assumptions match your stack; adapt if the repo differs.\n\n## UI stack\n- Tauri (Rust backend), React UI (TypeScript), Vite\n- Tailwind CSS v4 (CSS-first theme via `@theme`, container queries)\n- Radix UI Primitives (headless components) + your styling layer\n- Optional: Three.js / react-three-fiber for accents\n\n## App + agent tooling\n- OpenAI Apps SDK (and Apps SDK UI design system) for ChatGPT apps\n- MCP (Model Context Protocol) for tool connections (e.g., Figma)\n- Figma Make / Dev Mode as design inputs, when available\n\n## Quality pipeline\n- Storybook (component isolation + review surface)\n- Argos (visual regression)\n- Biome (format/lint), TypeScript checks\n\n## Backend (if relevant to the UI)\n- Cloudflare Workers + Hono\n- Auth0\n- SQLite + Drizzle (+ FTS5 optionally)\n- Zod validation\n\n---\n\n# Output contract (what to produce)\n\nWhen invoked, produce **at least** the following, unless the user explicitly says otherwise:\n\n1. **UI Brief** (use `assets/design-brief.md` template)\n2. **Component plan** (new/changed components, states, variants, data contract)\n3. **Motion plan** (use `assets/motion-spec.yml` template)\n4. **Tokens plan** (use `assets/tokens.json`; generate Tailwind theme if asked)\n5. **Implementation plan**:\n   - File paths\n   - Component APIs\n   - A11y notes\n   - Perf notes\n6. **Implementation patch** (if working in a repo): code + Storybook stories\n7. **Verification notes** (use `assets/acceptance-checklist.md`)\n\nIf information is missing, make reasonable assumptions and call them out explicitly.\n\n---\n\n# The golden loop (fast taste → real implementation)\n\nUse this loop; reorder steps freely:\n\n1. **Name the moment**: what is the user doing, and what should it feel like?\n2. **Sketch constraints**: layout, hierarchy, tokens, accessibility, performance budget.\n3. **Prototype 1** (fast): simplest working thing.\n4. **Prototype 2–3** (variants): explore 2 alternatives (spacing/motion/affordance).\n5. **Pick a direction**: articulate why (tradeoffs, user impact).\n6. **Polish pass**: spacing, typography, motion, copy, keyboard.\n7. **Quality gates**: a11y + perf + visual regression.\n8. **Package**: Storybook story, docs, and a short “how to extend” note.\n\n---\n\n# Workflows (copy/paste playbooks)\n\n## Workflow A — Code-first UI (Tailwind v4 + Radix)\nUse when you need to ship UI quickly and validate in real code.\n\n1. Pick or create tokens (semantic first).\n2. Implement layout with Tailwind utilities.\n3. Wrap behavior with Radix primitives.\n4. Style states via `data-*` and CSS variables.\n5. Add Storybook story and cover:\n   - default, hover/focus, disabled\n   - loading/error/empty where applicable\n6. Add motion (enter/exit/feedback), respecting reduced motion.\n\nDeliverables:\n- Component file(s)\n- Storybook story\n- Updated tokens/theme (if needed)\n- Notes on states + keyboard behavior\n\n## Workflow B — Figma-first UI (Make → Dev Mode → Code)\nUse when a Figma file exists or you can generate a first draft.\n\n1. Generate or review a first draft (Figma Make / design file).\n2. Identify:\n   - tokens/variables (colors, type scale, spacing, radii)\n   - components (buttons, inputs, dialogs)\n   - key states (loading/error/empty)\n3. Map design → code:\n   - tokens → Tailwind `@theme` variables\n   - components → Radix-based primitives\n4. Implement the UI in code and re-check in the running app/Storybook.\n\nIf MCP tooling is available, prefer “extract real values” over guessing.\n\nDeliverables:\n- Token mapping table (Figma variable → CSS var/Tailwind token)\n- Component spec(s)\n- Implemented components + Storybook stories\n\n### Figma Make best practices (from transcripts)\nSee `references/figma-make.md`.\n\n## Workflow C — Micro-interactions & motion pass\nUse when UI is functional but feels flat.\n\n1. Identify 1–2 key moments (hover, submit, success, error recovery).\n2. Add motion for:\n   - feedback (press, hover, drag)\n   - transition (enter/exit)\n   - continuity (reorder, expand/collapse)\n3. Keep motion fast; reduce friction; never block completion.\n4. Ensure:\n   - keyboard focus remains stable\n   - reduced-motion fallback exists\n   - performance stays smooth\n\nDeliverables:\n- Motion spec update\n- Implementation + Storybook story showing interactions\n\n## Workflow D — Three.js/WebGL accent (optional)\nUse for subtle delight (hero accent, background, celebratory moment), not core UI.\n\nRules:\n- Gate with feature flag / visibility heuristics.\n- Provide fallback (static image/CSS) and respect reduced motion.\n- Keep GPU cost bounded; prefer “accent” not “always animating”.\n\nDeliverables:\n- Small isolated scene component\n- Performance notes + fallback behavior\n- Toggle/flag and Storybook story\n\n## Workflow E — ChatGPT app UI (OpenAI Apps SDK)\nUse when building within the Apps SDK. Align to its UI patterns (cards, carousel, fullscreen).\n\nDeliverables:\n- View selection (inline vs fullscreen)\n- UX flow aligned to tool results and loading/error states\n- Components consistent with Apps SDK UI guidelines\n\n---\n\n# Implementation guardrails (don’t skip)\n\n## Accessibility (minimum bar)\n- Keyboard navigation for all controls\n- Visible focus states\n- Semantic structure (headings, landmarks)\n- Reduced motion (`prefers-reduced-motion`) behavior\n- Color contrast checks (use `scripts/contrast_check.mjs` if you have tokens)\n\n## Performance (minimum bar)\n- Avoid long main-thread tasks (especially with continuous animation)\n- Don’t animate layout; prefer transforms/opacity\n- Avoid re-render storms; memoize where needed\n- For WebGL: avoid always-on high-FPS backgrounds; throttle/idle\n\n## Quality (minimum bar)\n- Storybook story for each new/changed component\n- Argos snapshots for key variants\n- Biome/TypeScript clean\n- Document any non-obvious behavior (especially keyboard/focus)\n\n## Examples\n- \"Design a new settings panel for a Tauri app with a glassmorphism feel, but keep it accessible.\"\n- \"Refine this onboarding flow for React + Tailwind v4; add micro-interactions and a11y checks.\"\n- \"Prototype a dashboard layout with a subtle WebGL accent and a Storybook story.\"\n\n---\n\n# Assets, scripts, and where things live\n\n## Templates (assets/)\n- `assets/design-brief.md` — UI brief template\n- `assets/component-spec.md` — component spec template (Radix + Tailwind ready)\n- `assets/motion-spec.yml` — motion system template\n- `assets/tokens.json` — token starter set\n- `assets/acceptance-checklist.md` — definition-of-done checklist\n- `assets/prompt-flows.md` — ready-to-run prompts/flows for Codex + Claude Code\n\n## References (references/)\n- `references/influences.md` — links to the creators above + what to study\n- `references/stack.md` — links to Tailwind v4, Radix, Tauri, Apps SDK, MCP, Figma Make/MCP\n\n## Scripts (scripts/)\n- `node scripts/skill_lint.mjs` — validate SKILL front matter\n- `node scripts/tokens_to_tailwind_theme.mjs assets/tokens.json > theme.css` — generate Tailwind v4 `@theme`\n\n## Remember\n\nThe agent is capable of extraordinary work in this domain. These guidelines unlock that potential—they don't constrain it.\nUse judgment, adapt to context, and push boundaries when appropriate.\n- `node scripts/contrast_check.mjs assets/tokens.json` — quick contrast report\n- `node scripts/scaffold_component.mjs Button src/components/ui` — create a component + Storybook story + spec stub\n\n---\n\n# Invocation examples\n\n- `$ui-ux-creative-coding Design and implement a Settings screen (account + privacy) for our Tauri app. Include tokens, motion spec, and Storybook stories.`\n- `$ui-ux-creative-coding Add delight to this onboarding flow without hurting speed. Propose 3 variants and implement the best one.`\n- `$ui-ux-creative-coding Build a Radix Dialog with Tailwind v4 tokens, focus handling, and a polished open/close animation.`\n"
  }
}

thinking
**Preparing systematic interview approach**

I’m outlining a 3–7 step plan to clarify requirements by asking about platform, target UI, users, success metrics, brand, tone, scope, acceptance criteria, constraints, pages, states, data, interactions, motion, accessibility, performance, and dependencies. Next, I’ll prompt to confirm running a structured interview to explore this systematically.
codex
Objective: Use `ui-ux-creative-coding` to design a shippable UI direction + implementation plan, but first gather the minimum inputs you want to provide.

Plan (3–7 steps):
1) Confirm whether to run /interview-me for structured requirements.
2) Capture the core UI target (surface, users, goal, success signal).
3) Define constraints (platform/stack, routes, states, accessibility, motion).
4) Choose a visual direction + token strategy.
5) Draft the UI brief, component plan, and motion plan.
6) Propose the first implementation slice and verification steps.

Next step: decide if I should run the /interview-me flow to collect requirements in a structured way.

Should I use /interview-me to explore this systematically?
tokens used
37,669
